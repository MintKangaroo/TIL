# TIL - 2022.04.09  
# 오늘의 내용

## CS - DFS / BFS - 백준 1260번
: DFS / BFS의 개념을 이해하고 코드로 짜보기

<br/>

## DFS (깊이 우선 탐색)
![screensh](https://media.vlpt.us/images/lucky-korma/post/30737a15-9adf-49a6-96a0-98c211cab1cc/R1280x0.gif)  
: 위의 사진처럼 하나의 트리를 끝까지 탐색한 후 다음 트리로 넘어가는 방법(ex.미로 찾기를 할 때 하나의 길을 끝까지 가본다)  
- 사용하는 이유  
1. 모든 노드를 방문하고자 하는 경우에 이 방법을 선택함
2. 깊이 우선 탐색(DFS)이 너비 우선 탐색(BFS)보다 좀 더 간단함
3. 검색 속도 자체는 너비 우선 탐색(BFS)에 비해서 느림

<br />

## BFS (너비 우선 탐색)
![screensh](https://media.vlpt.us/images/lucky-korma/post/2112183b-bfcd-427e-8072-c9dc983180ba/R1280x0-2.gif)  
: 위의 사진처럼 Depth를 탐색한 후 다음 Depth로 넘어가는 방법
- 사용하는 예
1. 두 노드 사이의 최단 경로를 찾고 싶을 때 이 방법을 선택  

<br />

## DFS vs BFS
### DFS(깊이 우선 탐색)
- 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색	
- 스택 또는 재귀함수로 구현
### BFS(너비 우선 탐색)
- 현재 정점에 연결된 가까운 점들부터 탐색
- 큐를 이용해서 구현

## 예제 코드
![screensh](https://itholic.github.io/assets/images/2019/02/07/python-graph/graph.png)
이 그래프를 파이썬 코드로 구현해보자.

```
graph = {
    'A': ['B'],
    'B': ['A', 'C', 'H'],
    'C': ['B', 'D'],
    'D': ['C', 'E', 'G'],
    'E': ['D', 'F'],
    'F': ['E'],
    'G': ['D'],
    'H': ['B', 'I', 'J', 'M'],
    'I': ['H'],
    'J': ['H', 'K'],
    'K': ['J', 'L'],
    'L': ['K'],
    'M': ['H']
}
```

## BFS 구현
```
def bfs(graph, start_node):
    visit = list()
    queue = list()

    queue.append(start_node)

    while queue:
        node = queue.pop(0)
        if node not in visit:
            visit.append(node)
            queue.extend(graph[node])

    return visit
```
1. 방문했던 노드 리스트와 다음으로 방문할 노드의 목록을 차례대로 저장할 리스트를 만든다.
2. 시작 노드를 큐에 넣는다.
3. 큐의 목록이 바닥날 때까지 loop를 돌린다.
4. 큐의 맨앞에 있는 노드를 꺼내온다.
5. 해당 노드가 아직 방문 리스트에 없다면 방문 리스트에 추가하고
6. 해당 노드의 자식 노드들을 큐에 추가해준다.

## DFS 구현
```
def dfs(graph, start_node):
    visit = list()
    stack = list()

    stack.append(start_node)

    while stack:
        node = stack.pop()
        if node not in visit:
            visit.append(node)
            stack.extend(graph[node])

    return visit
```

- 코드 기준으로 봤을 때 DFS는 BFS와 거의 똑같지만 queue 대신 stack을 이용했다는 점이 다르다.

<br />

플러스 지식(1)  

<br /> 

파이썬 extend(iterable) 함수 vs append(x) 함수

두 함수 모두 리스트를 합치는 함수이다.

extend는 리스트 끝에 가장 바깥쪽 iterable의 모든 항목을 넣는다.

append : 리스트 끝에  x 1개를 그대로 넣는다.

#

플러스 지식(2)

파이썬 pop() vs pop(0)

pop()은 리스트의 뒷부분부터 제거

pop(0)은 리스트의 앞부분부터 제거

<br />

![screensh](https://mblogthumb-phinf.pstatic.net/MjAxOTA1MTlfNTEg/MDAxNTU4MjI1MjMzNzQ1.vrwM5Kdp03SAYSqqUHk1GHYreCf93CR4QgPXcAFlJ-gg.XL21JskF0EemeEjXwH4eMjX6r-pk9SQcCgInuygX_WMg.PNG.wideeyed/61.png?type=w800)


<br />

플러스 지식(3)

<br />

Stack VS Queue

Queue :  선입선출 - 먼저 들어온 데이터가 먼저 나가는 방식

<br />

![screensh](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZce3U%2FbtqBDaOfGU5%2FRc2kR3Puqi3QiQa3o6CPL1%2Fimg.png)

<br />

Stack : 나중에 들어온 데이터가 먼저 나가는 방식

<br />

![screensh](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fby1qnT%2FbtqBE1v1UlX%2FzbnXdYnGAXhMYbcDCca6WK%2Fimg.png)

#
참고
https://velog.io/@lucky-korma/DFS-BFS%EC%9D%98-%EC%84%A4%EB%AA%85-%EC%B0%A8%EC%9D%B4%EC%A0%90

예제 코드(1) https://velog.io/@_3juhwan/Python%EC%9C%BC%EB%A1%9C-DFS-BFS-%EA%B5%AC%ED%98%84  
예제 코드(2) https://data-marketing-bk.tistory.com/44  
예제 코드(3)https://itholic.github.io/python-bfs-dfs/

