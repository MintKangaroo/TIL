# TIL - 2022.04.10 
# 오늘의 내용

<br />

## CS - 에라토스테네스의 체 - 백준 1929번
: 기존의 소수를 구하는 방식(브루트포스)은 시간 초과 오류가 발생함 -> 다른 방법을 찾아야함

<br/>

## 에라토스테네스의 체
- 소수들을 대량으로 빠르고 정확하게 구하는 방법 - 소수(Prime Number) 판별 알고리즘

<br />

## 에라토스테네스의 체 알고리즘을 이용하는 이유
- 기존의 소수 판별 알고리즘은 시간 복잡도는 O(N)이다. 모든 경우의 수를 다 돌며 약수 여부를 확인한다는 점에서 몹시 비효율적이다. 
- 하지만 O(N^(1/2))로 손쉽게 계산할 수 있습니다. why? -> 8의 경우는 2 * 4 = 4 * 2와 같은 식으로 대칭을 이루기 때문입니다.  
-> 특정한 숫자의 제곱근까지만 약수의 여부를 검증하는 방법이다

<br />

## 에라토스테네스의 체 공식
1. 소수를 판별할 범위만큼 리스트롤 만든다.
2. 2부터 시작해서 특정 숫자의 배수에 해당하는 슷자들을 모두 지운다. (자기자신 제외 ex)2,3,5,7..)
3. 남은 숫자들을 출력

<br />

## 예제 코드


```
def prime_list(n):
    # 에라토스테네스의 체 초기화: n개 요소에 True 설정(소수로 간주)
    sieve = [True] * n

    m = int(n ** 0.5)
    for i in range(2, m + 1):
        if sieve[i] == True:           # i가 소수인 경우 
            for j in range(i+i, n, i): # i이후 i의 배수들을 False 판정
                sieve[j] = False

    # 소수 목록 산출
    return [i for i in range(2, n) if sieve[i] == True]
```
1. n은 소수를 판별할 범위의 마지막 숫자
2. n개의 True로 된 리스트 생성
3. 2 ~ (루트n + 1)까지의 소수의 배수를 리스트의 번호를 False로 변경
4. 나머지 출력

<br />

### 출처
https://blog.naver.com/PostView.naver?blogId=ndb796&logNo=221233595886&redirect=Dlog&widgetTypeCall=true&directAccess=false
https://this-programmer.tistory.com/409